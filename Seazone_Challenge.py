# importing libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import pandasql as ps
import warnings
from sklearn.metrics import r2_score, mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor, ExtraTreesRegressor
from sklearn.model_selection import train_test_split

warnings.simplefilter(action='ignore', category=FutureWarning)

# LOAD DATA AND PREPARATION

#display the listing table
listings = pd.read_csv('./listings-challenge.csv')
print(listings.head())

#Verify dataset shape, number of unique and null values per feature
def show_info(data):
    print('DATASET SHAPE: ', data.shape, '\n')
    print('-'*50)
    print('NUMBER OF UNIQUE VALUES PER FEATURE:', '\n')
    print(data.nunique())
    print('\n', '-'*50)
    print('NULL VALUES PER FEATURE')
    print(data.isnull().sum())
    
    
show_info(listings)

print('\nThere are some missing infomation but it will not affect the data analysis') 
print('A more detailed explanation can be found in the pdf report\n')

#display the revenue table
revenue = pd.read_csv('./daily_revenue.csv')
print(revenue.head())
show_info(revenue)
print('\n\n')

#the “creation_date” column of a given row should be always lesser or equal to the “date” column of the same row. 
#Therefore, the rows with the “creation_date” higher to the “date” will be excluded.
revenue = revenue[revenue['creation_date']<=revenue['date']]
print(revenue.head())

# verify if there is still any null values in the revenue table
print('\nNULL VALUES PER FEATURE\n')
print(revenue.isnull().sum())

#transform string into date time
revenue['creation_date'] = revenue['creation_date'].str.replace(' 00:00:00', '')
revenue['creation_date'] = revenue['creation_date'].astype(np.datetime64, copy=False)
revenue['date'] = revenue['date'].str.replace(' 00:00:00', '')
revenue['date'] = revenue['date'].astype(np.datetime64, copy=False)

# Insert 2 new columns into the revenue table related to the month and year of the ‘date’ column to make a heat map. 
revenue.insert(2, 'month', (revenue['date'].dt.month), allow_duplicates=False)
revenue.insert(3, 'year', (revenue['date'].dt.year), allow_duplicates=False)



print('\nTREATMENT OF OUTLIERS')

# create a heatmap
plt.figure(figsize=(15, 10))
print(sns.heatmap(revenue.corr(), annot=True, cmap='Blues'))
plt.show()

# define functions to create a boxplot and a histogram to visualize the outliers.
# it will be used as rule values below (Q1 - 1.5x Amplitude) and values above (Q3 + 1.5x Amplitude)
def limits(column):
    q1 = column.quantile(0.25)
    q3 = column.quantile(0.75)
    amplitude = q3 - q1
    return q1 - 1.5 * amplitude, q3 + 1.5 * amplitude


def histogram(column):
    plt.figure(figsize=(15, 5))
    sns.distplot(column, hist=True)
    plt.show()

    
def boxplot(column):
    fig, (ax1, ax2) = plt.subplots(1, 2)
    fig.set_size_inches(15, 5)
    sns.boxplot(x=column, ax=ax1)
    ax2.set_xlim(limits(column))
    sns.boxplot(x=column, ax=ax2)
    plt.show()

boxplot(revenue['revenue'])
histogram(revenue['revenue'])    

# It will be considered outliers those with revenue higher than 1250
outliers=revenue[revenue['revenue']>1250]
print('\nThe outlier revenue was R$'+str(outliers['revenue'].sum())+' in the period given\n')

#some outliers are possibly generated by the properties classified as MASTER
#Verify how many properties exist in each category and plot a bar graph 
types = ['SIM','JR','SUP','TOP','MASTER']
simplified_listings = pd.DataFrame(columns = ['Categorie' , 'Amount',])

for i in types:
    simplified_listings=simplified_listings.append({'Categorie' : i , 'Amount' : len(listings[listings['Categoria'].str.contains(i)])} , ignore_index=True)

print('\nAmount of properties by category:')
print(simplified_listings)
print('\nThe properties classified as MASTER represent '+str(round(simplified_listings['Amount'].loc[4]/simplified_listings['Amount'].sum()*100,2))+'%'+' of the total amount')

sns.barplot(x='Categorie', y='Amount', data=simplified_listings,)
plt.title('Categories X Total of Properties', size=15)
plt.xlabel("Categories")
plt.ylabel("Total")
plt.show()

#calculate the revenue of the master properties
master = listings[listings['Categoria'].str.contains('MASTER')]
master_revenue = 0

for i in master['Código']:
    master_revenue = master_revenue + revenue.loc[revenue['listing']==i]['revenue'].sum()

print('The revenue of the MASTER properties was R$'+str(master_revenue)+' in the period given\n')
total_revenue = revenue['revenue'].sum()
print('\nThe total revenue of the properties was R$'+str(total_revenue)+' in the period given')

percentage_master = round((master_revenue/total_revenue)*100,2)

print('The percentage of the master revenue compared to the total revenue was '+str(percentage_master)+'%')

#the master properties and the outliers will not be deleted

print('\n\nEXPLORATORY DATA ANALYSIS\n')

#Number of apartments, houses or hotels per location 
print('Number of apartments, houses or hotels per location:')
print(listings['Localização'].value_counts().head(10))

plt.figure( figsize=(12, 6))
sns.countplot(listings['Localização'], orient='h')
plt.title('Location X Total Properties', size=15)
plt.xticks(rotation=90)
plt.xlabel("Location")
plt.ylabel("Total of Properties")
plt.show()

#Amount of properties per status
print('\nAmount of properties per Status:')
print(listings['Status'].value_counts())
print ('Total: '+ str(listings['Status'].value_counts().sum()))

sns.countplot(listings['Status'], orient='h')
plt.title('Status X Total of Properties', size=15)
plt.xlabel("Status")
plt.ylabel("Total of Properties")
plt.show()

#investigate inactive properties
inactive_properties = listings[listings['Status']=='Inativo']

#per location
sns.countplot(inactive_properties['Localização'], orient='h')
plt.title('Inactive Properties per Location', size=15)
plt.xticks(rotation=90)
plt.show()

#per categorie
sns.countplot(inactive_properties['Categoria'], orient='h')
plt.title('Inactive Properties per Categorie', size=15)
plt.xticks(rotation=90)
plt.show()

#amount of properties per type
print('\nAmount of properties per Type:')
print(listings['Tipo'].value_counts())

sns.countplot(listings['Tipo'], orient='h')
plt.title('Type X Total of Properties', size=15)
plt.xlabel("Type")
plt.ylabel("Total of Properties")
plt.show()

#Separate the data from 2020 and 2021
revenue_2020 = revenue[(revenue['date']>='2020-01-01 00:00:00') & (revenue['date']<'2021-01-01 00:00:00')]
revenue_2021 = revenue[(revenue['date']>='2021-01-01 00:00:00') & (revenue['date']<'2022-01-01 00:00:00')]

#Top 10 hotel, apartment or house with the best revenue and the total revenue of 2020
print('\n\nTop 10 hotel, apartment or house with the best revenue in 2020:')
query = """select listing, sum(revenue) as total_revenue
from revenue_2020
group by listing
order by total_revenue desc"""
revenue_2020 = ps.sqldf(query, locals())
print(revenue_2020.head(10))

plt.figure( figsize=(10, 5))
sns.barplot(x='listing', y='total_revenue', data=revenue_2020.head(10),)
plt.title('The most rentable places in 2020', size=15)
plt.xticks(rotation=90)
plt.xlabel("Listing")
plt.ylabel("Revenue")
plt.show()

#Top 10 hotel, apartment or house with the best revenue and the total revenue of 2021
print('\n\nTop 10 hotel, apartment or house with the best revenue in 2020:')
query = """select listing, sum(revenue) as total_revenue
from revenue_2021
group by listing
order by total_revenue desc"""
revenue_2021 = ps.sqldf(query, locals())
print(revenue_2021.head(10))

plt.figure( figsize=(10, 5))
sns.barplot(x='listing', y='total_revenue', data=revenue_2021.head(10),)
plt.title('The most rentable places in 2021', size=15)
plt.xticks(rotation=90)
plt.xlabel("Listing")
plt.ylabel("Revenue")
plt.show()

#Revenue in 2020 and 2021 and the percetage comparing those 2 years
print('\nThe revenue in 2020 was R$'+ str(round(revenue_2020['total_revenue'].sum(),2)))
print('The revenue in 2021 was R$'+ str(round(revenue_2021['total_revenue'].sum(),2)))
print('The revenue in 2021 was '+ str(round((revenue_2021['total_revenue'].sum()-revenue_2020['total_revenue'].sum())/revenue_2020['total_revenue'].sum(),2)*100)+'% higher than 2020')


print('\n\nANSWERING THE QUESTIONS')

#prepare the machine learning model that will be used
def evaluate_model(name_model, y_test, forecast):
    r2 = r2_score(y_test, forecast)
    RSME = np.sqrt(mean_squared_error(y_test, forecast))
    return f'Model {name_model}:\nR²:{r2:.2%}\nRSME:{RSME:.2f}'

model_rf = RandomForestRegressor()
model_lr = LinearRegression()
model_et = ExtraTreesRegressor()

models = {'RandomForest': model_rf,
          'LinearRegression': model_lr,
          'ExtraTrees': model_et,
          }


#1)What is the expected price and revenue for a listing tagged as JUR MASTER 2Q in march?
print('\n1)What is the expected price and revenue for a listing tagged as JUR MASTER 2Q in march?\n')
print(listings[(listings['Categoria']=='MASTER2Q') & (listings['Localização']=='JUR')])
print('\nThere is no MASTER2Q in JUR\n')

print(listings[listings['Categoria'].str.contains('MASTER')& (listings['Localização']=='JUR')])

#We will use the propertie CVJ302, a MASTER3Q in JUR
print('The propertie CVJ302 (MASTER3Q in JUR) will be used instead\n')
print(revenue[revenue['listing']=='CVJ302'].head())
print('\nThis property has '+str(len(revenue[revenue['listing']=='CVJ302']))+' registrations\n\n')

#drop the columns: listings, date and creation_date
jur_master3q = revenue[revenue['listing']=='CVJ302']
jur_master3q = jur_master3q.drop(columns=["listing","date", "creation_date"])

#Insert the data in the variables
y = jur_master3q.drop(['month', 'year', 'occupancy', 'blocked'], axis=1)
X = jur_master3q.drop(['revenue', 'last_offered_price'], axis=1)

#training the model
X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=20)

for name_model, model in models.items():
    #train
    model.fit(X_train, y_train)
    #testar
    forecast = model.predict(X_test)
    print(evaluate_model(name_model, y_test, forecast))

#The importance of the columns in the forecast.
print('\nThe importance of the columns in the forecast:')
important_features = pd.DataFrame(model_rf.feature_importances_, X_train.columns)
important_features = important_features.sort_values(by=0, ascending=False)
print(important_features)
plt.figure(figsize=(8, 3))
ax = sns.barplot(x=important_features.index, y=important_features[0])
ax.tick_params(axis='x', rotation=90)

#The forecast
march_2022 = {'month': 3, 'year': 2022, 'occupancy': 1, 'blocked': 0}
forecast_march = pd.DataFrame(march_2022, index=[0])
price_revenue = model_et.predict(forecast_march)
print('\nThe expected price and revenue for a listing tagged as JUR MASTER 3Q in march is respectively:')
print(price_revenue)


#2) What is Seazone’s expected revenue for 2022? Why?
print('\n\n2)What is Seazone’s expected revenue for 2022? Why?')

#Calculate the monthly revenue per year
months = [1,2,3,4,5,6,7,8,9,10,11,12]
years = [2019,2020,2021,2022] 
revenue_month = pd.DataFrame(columns = ['month' , 'year', 'revenue'])

for i in years:
    for j in months:   
        df = revenue[(revenue['year']== i) & (revenue['month']==j)]
        profit = df['revenue'].sum()
        revenue_month = revenue_month.append({'month' : j , 'year' : i, 'revenue': profit} , ignore_index=True)

revenue_month = revenue_month[revenue_month['revenue']>0]

#Remove data from 03/2020 to 12/2020 because of the atypical pandemic and remove data from 03/2022
revenue_2022 = revenue_month[((revenue_month['year']==2022) & (revenue_month['month']<=3))]
revenue_2022 = revenue_2022.drop('year', axis=1)
revenue_month = revenue_month[((revenue_month['year']<=2022) & (revenue_month['month']<3))| (revenue_month['year']<2022)]
print('\n')
print(revenue_month.head())

#Insert the data in the variables
y = revenue_month['revenue']
X = revenue_month.drop('revenue', axis=1)

print('\n')

#train the model
X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=20)

for name_model, model in models.items():
    #train
    model.fit(X_train, y_train)
    #testar
    forecast = model.predict(X_test)
    print(evaluate_model(name_model, y_test, forecast))

print('\n')

#forecast each monthly revenue of 2022 starting from march
months = [3,4,5,6,7,8,9,10,11,12]
for i in months:
    data_2022 = {'month': i, 'year': 2022 }
    forecast_2022 = pd.DataFrame(data_2022, index=[0])
    price_revenue = model_rf.predict(forecast_2022)
    revenue_2022= revenue_2022.append({'month' : i, 'revenue': price_revenue} , ignore_index=True)

revenue_2022['revenue'] = revenue_2022['revenue'].astype(np.float64, copy=False)
revenue_2022['revenue'] = round(revenue_2022['revenue'],2)
print(revenue_2022)
print('\nThe expected revenue for 2022 is R$'+str(round(revenue_2022['revenue'].sum(),2))+'\n')

#3)How many reservations should we expect to sell per day?
print('\n\n3)How many reservations should we expect to sell per day?\n')
#use the 'creation_data' column to calculate how many reservations there were in 2021.
auxdf_2021 = revenue.drop(['month','year'], axis=1)
auxdf_2021 = auxdf_2021[(auxdf_2021['creation_date']>='2021-01-01 00:00:00') & (auxdf_2021['creation_date']<'2022-01-01 00:00:00')]

#The data that is blocked must be removed because do not represent a reservation 
auxdf_2021 = auxdf_2021[auxdf_2021['blocked']==0]
auxdf_2021 = auxdf_2021.drop('blocked', axis=1)
print(auxdf_2021.head())
print('\n')

# Create 2 new columns:‘creation_date+1’ (the creation_date of the following line) and ‘creation_date-1' (the creation_date of the past line).
auxdf_2021.insert(6, 'creation_date+1', (auxdf_2021['creation_date'].shift()), allow_duplicates=False)
auxdf_2021.insert(7, 'creation_date-1', (auxdf_2021['creation_date'].shift(-1)), allow_duplicates=False)

#To know how many reservations were done per day, the ‘creation_date’ must be equal to the ‘creation_date’ 
# of the following day and different to the past day. 
reservations_2021 = pd.DataFrame(columns = ['creation_date' , 'Reservation'])
for index, row in auxdf_2021.iterrows():
    if (row["creation_date"] ==  row["creation_date+1"]):
        if (row["creation_date"] !=  row["creation_date-1"]):
            reservations_2021 = reservations_2021.append({'creation_date': row["creation_date"], 'Reservation': 1}, ignore_index=True)

#count the reservations per day
reservations_2021=reservations_2021.groupby("creation_date").count()
reservations_2021=reservations_2021.reset_index()


#create columns of the day, month and year to manipulate the data easier
reservations_2021.insert(0, 'day', (reservations_2021['creation_date'].dt.day), allow_duplicates=False)
reservations_2021.insert(0, 'month', (reservations_2021['creation_date'].dt.month), allow_duplicates=False)
reservations_2021.insert(0, 'year', (reservations_2021['creation_date'].dt.year), allow_duplicates=False)
reservations_2021=reservations_2021.drop(columns=['creation_date'])
print('Reservations per day in 2021:')
print(reservations_2021.head())

#insert the data in the variables
y = reservations_2021['Reservation']
X = reservations_2021.drop('Reservation', axis=1)

print('\n')

#train the model
X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=10)

for name_model, model in models.items():
    #train
    model.fit(X_train, y_train)
    #testar
    forecast = model.predict(X_test)
    print(evaluate_model(name_model, y_test, forecast))

#Create a data frame to forecast the reservations per day in 2022
forecast_2022 = reservations_2021.drop(['year'], axis=1)
forecast_2022.insert(0, 'year', 2022, allow_duplicates=False)

#Forecast the reservations per day of 2022
for index, row in forecast_2022.iterrows():
    isert_day = {'month': row["month"], 'year': row["year"], 'day': row["day"]}
    isert_day = pd.DataFrame(isert_day, index=[0])
    forecast_reservation = model_et.predict(isert_day)
    row["Reservation"] = forecast_reservation

print('\n')      

#avarage of the reservations per month
permonth = pd.DataFrame(columns = ['month' , 'reservation_per_day'])
months= [1,2,3,4,5,6,7,8,9,10,11,12]
for i in months:
    x = forecast_2022[forecast_2022['month']==i]
    permonth = permonth.append({'month': i, 'reservation_per_day': round(np.average(x['Reservation']),0)}, ignore_index=True)
print(permonth)

print('\nThe result is not compatible with the seasonality')

#Using the original 2021 database to calculate the average of reservations per month
permonth = pd.DataFrame(columns = ['month' , 'reservation_per_day'])
months= [1,2,3,4,5,6,7,8,9,10,11,12]
for i in months:
    x = reservations_2021[reservations_2021['month']==i]
    permonth = permonth.append({'month': i, 'reservation_per_day': round(np.average(x['Reservation']),0)}, ignore_index=True)

print('\nThe reservations should we expect to sell per day is different in each month:\n')
print(permonth)


#4)At what time of the year should we expect to have sold 10 of our new years nights? And 50%? And 80%?
print('\n\n4)At what time of the year should we expect to have sold 10 of our new years nights? And 50%? And 80%?')
print('How can this information be useful for pricing our listings?\n')

#filter to display only the 31-12-2021 nights
new_year = revenue[(revenue['date']=='2021-12-31')]
new_year = new_year.sort_values(by=['creation_date'])
print(new_year.head())

#Filter only active and not blocked properties
properties_availabe = listings[listings['Status']=='Ativo']
properties_availabe = properties_availabe['Código'].nunique()
print('\nThere are '+str(properties_availabe)+' properties availabe to rent')
blocked = new_year[new_year['blocked']==1]
print(str(blocked['listing'].count())+' landlords blocked their properties for the new years nights')
properties_availabe = properties_availabe - blocked['listing'].count()
print('Therefore there are '+str(properties_availabe)+' properties available')

print('\n10'+'%'+' of new years nights is equivalent to '+ str(round(properties_availabe*0.1,0))+' properties')
print('50'+'%'+' of new years nights is equivalent to '+ str(round(properties_availabe*0.5,0))+' properties')
print('80'+'%'+' of new years nights is equivalent to '+ str(round(properties_availabe*0.8,0))+' properties\n')

#crate columns of the day, month and year of the creation_date
new_year = new_year.drop(columns=['month','year'])
new_year.insert(7, 'day', (new_year['creation_date'].dt.day), allow_duplicates=False)
new_year.insert(8, 'month', (new_year['creation_date'].dt.month), allow_duplicates=False)
new_year.insert(9, 'year', (new_year['creation_date'].dt.year), allow_duplicates=False)
new_year = new_year[new_year['year']<2022]
new_year = new_year[new_year['blocked']==0]
new_year = new_year.drop(columns=['creation_date'])
new_year.reset_index(inplace=True, drop=True)
print(new_year.head())

#At what time od the year the 28º property was rented
print('\n\n')
print(new_year[new_year.index==27])
print('\n10'+'%'+' of the new years nights was sold in 10/19/2021')

#At what time od the year the 140º property was rented
print('\n')
print(new_year[new_year.index==139])
print('\n50'+'%'+' of the new years nights was sold in 12/11/2021')

#At what time od the year the 224 property was rented
print('\n')
print(new_year[new_year.index==223])
print('\n80'+'%'+' of the new years nights was sold in 12/27/2021')